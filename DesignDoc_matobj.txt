Objects:

MatchParams() # dict
    This will have all the defaults
    And users can customize this however they want
	Ended up just hiding this inside of Matcher

Matcher(params=MatchParams())
    This thing will hold all the matching thresholds
    and settings


MatchResult(params=None)
    This will hold all the properties of an actual match

Workflow
    
    # Custom thresholds for setting state
    params = MatchParams(sizesim=0.80) 
    matcher = Matcher(params)
    result = matcher.match(entry1, entry2)
    result.sizesim
    # 0.91
    result.state
    # True

    # Default truvari params for matching
    matcher = Matcher()
    result = matcher.match(entry1, entry2)
    result.state
    # False


How does the affect the current code?

    bench.py is the primary code using this. Making the matobjs will put `truvari.build_match`
    into the new Matcher

    Won't need to use `shared_space.args` to figure out thresholds (at least in build_match)

    Though I kinda want to put filter_call inside of this also. It using `shared_space` makes
    it unusable. Granted I would need to pass the `Matcher` to `chunker` and `compare_chunks`, but 
    that's okay
	I did

    `compare_chunks` and chunker should be renamed. Not super useful. `compare_chunks` should be 
    named something like `make_vcf_chunks`. Which is like something we already have, in `ref_ranges`.
    Difference being that `make_vcf_chunks` isn't just arbitrary chunks, but is informed by the vcf.
	These as utils is going to be good, but I don't think they're generic enough, yet.

    I also think I could reduce file reading by having a `make_vcf_chunks` which will actually 
    return the vcf entries vs a `make_vcf_ref_chunks` where I make the chrom,start,end reference ranges
    based on the VCF.
    	I pretty much did this

Who would use this?
    - Anyone who wanted to script up comparing VCF entries. This could make reuse inside of collapse really easy.
    - It could make potential annotation scripts much easier build. 
    - Plus, if I were able to 'emulate' a pysam.VariantRecord off of things like - reading a custom BED, I can then 
    do comparisons between pysam.VariantRecords and bed_emulating_variant_record

